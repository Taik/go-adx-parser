// Code generated by protoc-gen-gogo.
// source: proto_openx/openx_rtb.proto
// DO NOT EDIT!

/*
	Package openx_rtb is a generated protocol buffer package.

	It is generated from these files:
		proto_openx/openx_rtb.proto

	It has these top-level messages:
		ExtKeyValue
		Deal
		App
		Site
		Video
		AdId
		Geo
		Device
		User
		ThirdPartyKeyValue
		BidRequest
		BidResponse
		Bid
		AuctionResults
		AuctionResult
		Publisher
*/
package openx_rtb

import proto "github.com/golang/protobuf/proto"
import math "math"

import io "io"
import fmt "fmt"
import github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type DealPricingType int32

const (
	DealPricingType_fixed DealPricingType = 1
	DealPricingType_floor DealPricingType = 2
)

var DealPricingType_name = map[int32]string{
	1: "fixed",
	2: "floor",
}
var DealPricingType_value = map[string]int32{
	"fixed": 1,
	"floor": 2,
}

func (x DealPricingType) Enum() *DealPricingType {
	p := new(DealPricingType)
	*p = x
	return p
}
func (x DealPricingType) String() string {
	return proto.EnumName(DealPricingType_name, int32(x))
}
func (x *DealPricingType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DealPricingType_value, data, "DealPricingType")
	if err != nil {
		return err
	}
	*x = DealPricingType(value)
	return nil
}

type DealExclusivity int32

const (
	DealExclusivity_other_bids_accepted DealExclusivity = 0
	DealExclusivity_deal_bids_only      DealExclusivity = 1
)

var DealExclusivity_name = map[int32]string{
	0: "other_bids_accepted",
	1: "deal_bids_only",
}
var DealExclusivity_value = map[string]int32{
	"other_bids_accepted": 0,
	"deal_bids_only":      1,
}

func (x DealExclusivity) Enum() *DealExclusivity {
	p := new(DealExclusivity)
	*p = x
	return p
}
func (x DealExclusivity) String() string {
	return proto.EnumName(DealExclusivity_name, int32(x))
}
func (x *DealExclusivity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DealExclusivity_value, data, "DealExclusivity")
	if err != nil {
		return err
	}
	*x = DealExclusivity(value)
	return nil
}

type AuctionStatus int32

const (
	AuctionStatus_win   AuctionStatus = 1
	AuctionStatus_loss  AuctionStatus = 2
	AuctionStatus_error AuctionStatus = 3
)

var AuctionStatus_name = map[int32]string{
	1: "win",
	2: "loss",
	3: "error",
}
var AuctionStatus_value = map[string]int32{
	"win":   1,
	"loss":  2,
	"error": 3,
}

func (x AuctionStatus) Enum() *AuctionStatus {
	p := new(AuctionStatus)
	*p = x
	return p
}
func (x AuctionStatus) String() string {
	return proto.EnumName(AuctionStatus_name, int32(x))
}
func (x *AuctionStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AuctionStatus_value, data, "AuctionStatus")
	if err != nil {
		return err
	}
	*x = AuctionStatus(value)
	return nil
}

// Linearity follows OpenRTB 2.1 Table 6.6
type Video_VideoLinearity int32

const (
	Video_linear    Video_VideoLinearity = 1
	Video_nonlinear Video_VideoLinearity = 2
)

var Video_VideoLinearity_name = map[int32]string{
	1: "linear",
	2: "nonlinear",
}
var Video_VideoLinearity_value = map[string]int32{
	"linear":    1,
	"nonlinear": 2,
}

func (x Video_VideoLinearity) Enum() *Video_VideoLinearity {
	p := new(Video_VideoLinearity)
	*p = x
	return p
}
func (x Video_VideoLinearity) String() string {
	return proto.EnumName(Video_VideoLinearity_name, int32(x))
}
func (x *Video_VideoLinearity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Video_VideoLinearity_value, data, "Video_VideoLinearity")
	if err != nil {
		return err
	}
	*x = Video_VideoLinearity(value)
	return nil
}

// Protocol follows OpenRTB 2.1 Table 6.7
type Video_VideoBidResponseProtocol int32

const (
	Video_vast_1         Video_VideoBidResponseProtocol = 1
	Video_vast_2         Video_VideoBidResponseProtocol = 2
	Video_vast_3         Video_VideoBidResponseProtocol = 3
	Video_vast_1_wrapper Video_VideoBidResponseProtocol = 4
	Video_vast_2_wrapper Video_VideoBidResponseProtocol = 5
	Video_vast_3_wrapper Video_VideoBidResponseProtocol = 6
)

var Video_VideoBidResponseProtocol_name = map[int32]string{
	1: "vast_1",
	2: "vast_2",
	3: "vast_3",
	4: "vast_1_wrapper",
	5: "vast_2_wrapper",
	6: "vast_3_wrapper",
}
var Video_VideoBidResponseProtocol_value = map[string]int32{
	"vast_1":         1,
	"vast_2":         2,
	"vast_3":         3,
	"vast_1_wrapper": 4,
	"vast_2_wrapper": 5,
	"vast_3_wrapper": 6,
}

func (x Video_VideoBidResponseProtocol) Enum() *Video_VideoBidResponseProtocol {
	p := new(Video_VideoBidResponseProtocol)
	*p = x
	return p
}
func (x Video_VideoBidResponseProtocol) String() string {
	return proto.EnumName(Video_VideoBidResponseProtocol_name, int32(x))
}
func (x *Video_VideoBidResponseProtocol) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Video_VideoBidResponseProtocol_value, data, "Video_VideoBidResponseProtocol")
	if err != nil {
		return err
	}
	*x = Video_VideoBidResponseProtocol(value)
	return nil
}

type ExtKeyValue struct {
	Key              *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ExtKeyValue) Reset()         { *m = ExtKeyValue{} }
func (m *ExtKeyValue) String() string { return proto.CompactTextString(m) }
func (*ExtKeyValue) ProtoMessage()    {}

func (m *ExtKeyValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ExtKeyValue) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type Deal struct {
	DealId *string `protobuf:"bytes,1,opt,name=deal_id" json:"deal_id,omitempty"`
	// Optional Parameters for Non guaranteed deals
	DealCpmMicros    *int64           `protobuf:"varint,2,opt,name=deal_cpm_micros" json:"deal_cpm_micros,omitempty"`
	DealPricingType  *DealPricingType `protobuf:"varint,3,opt,name=deal_pricing_type,enum=DealPricingType" json:"deal_pricing_type,omitempty"`
	DealExclusivity  *DealExclusivity `protobuf:"varint,4,opt,name=deal_exclusivity,enum=DealExclusivity" json:"deal_exclusivity,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *Deal) Reset()         { *m = Deal{} }
func (m *Deal) String() string { return proto.CompactTextString(m) }
func (*Deal) ProtoMessage()    {}

func (m *Deal) GetDealId() string {
	if m != nil && m.DealId != nil {
		return *m.DealId
	}
	return ""
}

func (m *Deal) GetDealCpmMicros() int64 {
	if m != nil && m.DealCpmMicros != nil {
		return *m.DealCpmMicros
	}
	return 0
}

func (m *Deal) GetDealPricingType() DealPricingType {
	if m != nil && m.DealPricingType != nil {
		return *m.DealPricingType
	}
	return DealPricingType_fixed
}

func (m *Deal) GetDealExclusivity() DealExclusivity {
	if m != nil && m.DealExclusivity != nil {
		return *m.DealExclusivity
	}
	return DealExclusivity_other_bids_accepted
}

type App struct {
	// Subset of app object attributes defined in OpenRTB 2.1
	Id     *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name   *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Bundle *string `protobuf:"bytes,3,opt,name=bundle" json:"bundle,omitempty"`
	// (e.g., com.foo.mygame). This is
	// intended to be a unique ID across
	// multiple exchanges.
	Publisher        *Publisher `protobuf:"bytes,4,opt,name=publisher" json:"publisher,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *App) Reset()         { *m = App{} }
func (m *App) String() string { return proto.CompactTextString(m) }
func (*App) ProtoMessage()    {}

func (m *App) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *App) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *App) GetBundle() string {
	if m != nil && m.Bundle != nil {
		return *m.Bundle
	}
	return ""
}

func (m *App) GetPublisher() *Publisher {
	if m != nil {
		return m.Publisher
	}
	return nil
}

type Site struct {
	// Subset of site object attributes defined in OpenRTB 2.3 (sec 3.2.6)
	Id               *string    `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Publisher        *Publisher `protobuf:"bytes,2,opt,name=publisher" json:"publisher,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *Site) Reset()         { *m = Site{} }
func (m *Site) String() string { return proto.CompactTextString(m) }
func (*Site) ProtoMessage()    {}

func (m *Site) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *Site) GetPublisher() *Publisher {
	if m != nil {
		return m.Publisher
	}
	return nil
}

type Video struct {
	Mimes            []string                        `protobuf:"bytes,1,rep,name=mimes" json:"mimes,omitempty"`
	Linearity        *Video_VideoLinearity           `protobuf:"varint,2,opt,name=linearity,enum=Video_VideoLinearity" json:"linearity,omitempty"`
	Minduration      *int32                          `protobuf:"varint,3,opt,name=minduration" json:"minduration,omitempty"`
	Maxduration      *int32                          `protobuf:"varint,4,opt,name=maxduration" json:"maxduration,omitempty"`
	Protocol         *Video_VideoBidResponseProtocol `protobuf:"varint,5,opt,name=protocol,enum=Video_VideoBidResponseProtocol" json:"protocol,omitempty"`
	Startdelay       *int32                          `protobuf:"varint,6,opt,name=startdelay" json:"startdelay,omitempty"`
	XXX_unrecognized []byte                          `json:"-"`
}

func (m *Video) Reset()         { *m = Video{} }
func (m *Video) String() string { return proto.CompactTextString(m) }
func (*Video) ProtoMessage()    {}

func (m *Video) GetMimes() []string {
	if m != nil {
		return m.Mimes
	}
	return nil
}

func (m *Video) GetLinearity() Video_VideoLinearity {
	if m != nil && m.Linearity != nil {
		return *m.Linearity
	}
	return Video_linear
}

func (m *Video) GetMinduration() int32 {
	if m != nil && m.Minduration != nil {
		return *m.Minduration
	}
	return 0
}

func (m *Video) GetMaxduration() int32 {
	if m != nil && m.Maxduration != nil {
		return *m.Maxduration
	}
	return 0
}

func (m *Video) GetProtocol() Video_VideoBidResponseProtocol {
	if m != nil && m.Protocol != nil {
		return *m.Protocol
	}
	return Video_vast_1
}

func (m *Video) GetStartdelay() int32 {
	if m != nil && m.Startdelay != nil {
		return *m.Startdelay
	}
	return 0
}

// identification for single matching ad
type AdId struct {
	CampaignId       *int32  `protobuf:"varint,1,req,name=campaign_id" json:"campaign_id,omitempty"`
	PlacementId      *int32  `protobuf:"varint,2,req,name=placement_id" json:"placement_id,omitempty"`
	CreativeId       *int32  `protobuf:"varint,3,req,name=creative_id" json:"creative_id,omitempty"`
	DeprecatedDealId *string `protobuf:"bytes,4,opt,name=deprecated_deal_id" json:"deprecated_deal_id,omitempty"`
	// When specified, Ad Size below will override Ad Size found in Bid Request
	AdHeight *int32 `protobuf:"varint,5,opt,name=ad_height" json:"ad_height,omitempty"`
	AdWidth  *int32 `protobuf:"varint,6,opt,name=ad_width" json:"ad_width,omitempty"`
	// Private Premium support
	Deal *Deal `protobuf:"bytes,7,opt,name=deal" json:"deal,omitempty"`
	// For partial compatibility with older versions
	// of this protocol, this field will contain the first
	// deal in the bid request, but new code should use
	// the eligible_deals field instead.
	EligibleDeals    []*Deal `protobuf:"bytes,8,rep,name=eligible_deals" json:"eligible_deals,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *AdId) Reset()         { *m = AdId{} }
func (m *AdId) String() string { return proto.CompactTextString(m) }
func (*AdId) ProtoMessage()    {}

func (m *AdId) GetCampaignId() int32 {
	if m != nil && m.CampaignId != nil {
		return *m.CampaignId
	}
	return 0
}

func (m *AdId) GetPlacementId() int32 {
	if m != nil && m.PlacementId != nil {
		return *m.PlacementId
	}
	return 0
}

func (m *AdId) GetCreativeId() int32 {
	if m != nil && m.CreativeId != nil {
		return *m.CreativeId
	}
	return 0
}

func (m *AdId) GetDeprecatedDealId() string {
	if m != nil && m.DeprecatedDealId != nil {
		return *m.DeprecatedDealId
	}
	return ""
}

func (m *AdId) GetAdHeight() int32 {
	if m != nil && m.AdHeight != nil {
		return *m.AdHeight
	}
	return 0
}

func (m *AdId) GetAdWidth() int32 {
	if m != nil && m.AdWidth != nil {
		return *m.AdWidth
	}
	return 0
}

func (m *AdId) GetDeal() *Deal {
	if m != nil {
		return m.Deal
	}
	return nil
}

func (m *AdId) GetEligibleDeals() []*Deal {
	if m != nil {
		return m.EligibleDeals
	}
	return nil
}

// Additional attributes in RTB
type Geo struct {
	// openRTB-compliant fields
	Lat     *float32 `protobuf:"fixed32,1,opt,name=lat" json:"lat,omitempty"`
	Lon     *float32 `protobuf:"fixed32,2,opt,name=lon" json:"lon,omitempty"`
	Country *string  `protobuf:"bytes,3,opt,name=country" json:"country,omitempty"`
	City    *string  `protobuf:"bytes,4,opt,name=city" json:"city,omitempty"`
	Zip     *string  `protobuf:"bytes,5,opt,name=zip" json:"zip,omitempty"`
	Type    *int32   `protobuf:"varint,6,opt,name=type" json:"type,omitempty"`
	// openx-specific fields
	Continent        *string `protobuf:"bytes,7,opt,name=continent" json:"continent,omitempty"`
	State            *string `protobuf:"bytes,8,opt,name=state" json:"state,omitempty"`
	Dma              *int32  `protobuf:"varint,9,opt,name=dma" json:"dma,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Geo) Reset()         { *m = Geo{} }
func (m *Geo) String() string { return proto.CompactTextString(m) }
func (*Geo) ProtoMessage()    {}

func (m *Geo) GetLat() float32 {
	if m != nil && m.Lat != nil {
		return *m.Lat
	}
	return 0
}

func (m *Geo) GetLon() float32 {
	if m != nil && m.Lon != nil {
		return *m.Lon
	}
	return 0
}

func (m *Geo) GetCountry() string {
	if m != nil && m.Country != nil {
		return *m.Country
	}
	return ""
}

func (m *Geo) GetCity() string {
	if m != nil && m.City != nil {
		return *m.City
	}
	return ""
}

func (m *Geo) GetZip() string {
	if m != nil && m.Zip != nil {
		return *m.Zip
	}
	return ""
}

func (m *Geo) GetType() int32 {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return 0
}

func (m *Geo) GetContinent() string {
	if m != nil && m.Continent != nil {
		return *m.Continent
	}
	return ""
}

func (m *Geo) GetState() string {
	if m != nil && m.State != nil {
		return *m.State
	}
	return ""
}

func (m *Geo) GetDma() int32 {
	if m != nil && m.Dma != nil {
		return *m.Dma
	}
	return 0
}

type Device struct {
	// openRTB-compliant fields
	Didsha1 *string `protobuf:"bytes,1,opt,name=didsha1" json:"didsha1,omitempty"`
	Dnt     *int32  `protobuf:"varint,2,opt,name=dnt" json:"dnt,omitempty"`
	// then do not track Is set to
	// false, if "1", then do no track
	// is set to true in browser.
	Ua      *string `protobuf:"bytes,3,opt,name=ua" json:"ua,omitempty"`
	Ip      *string `protobuf:"bytes,4,opt,name=ip" json:"ip,omitempty"`
	Carrier *string `protobuf:"bytes,5,opt,name=carrier" json:"carrier,omitempty"`
	// Network Code
	Os             *string  `protobuf:"bytes,6,opt,name=os" json:"os,omitempty"`
	Osv            *string  `protobuf:"bytes,7,opt,name=osv" json:"osv,omitempty"`
	Language       []string `protobuf:"bytes,8,rep,name=language" json:"language,omitempty"`
	Make           *string  `protobuf:"bytes,9,opt,name=make" json:"make,omitempty"`
	Model          *string  `protobuf:"bytes,10,opt,name=model" json:"model,omitempty"`
	Connectiontype *string  `protobuf:"bytes,11,opt,name=connectiontype" json:"connectiontype,omitempty"`
	// for the device Values are wifi,
	// cell, cell-2G, cell-3G, cell-4G
	DeprecatedApi *string `protobuf:"bytes,12,opt,name=deprecated_api" json:"deprecated_api,omitempty"`
	// repeated int32 should be used.
	Geo *Geo `protobuf:"bytes,13,opt,name=geo" json:"geo,omitempty"`
	// openx-specific fields
	Browser        *string `protobuf:"bytes,14,opt,name=browser" json:"browser,omitempty"`
	BrowserVersion *string `protobuf:"bytes,15,opt,name=browser_version" json:"browser_version,omitempty"`
	Api            []int32 `protobuf:"varint,16,rep,name=api" json:"api,omitempty"`
	Odin1          *string `protobuf:"bytes,17,opt,name=odin1" json:"odin1,omitempty"`
	Openudid       *string `protobuf:"bytes,18,opt,name=openudid" json:"openudid,omitempty"`
	Secureudid     *string `protobuf:"bytes,19,opt,name=secureudid" json:"secureudid,omitempty"`
	Idforad        *string `protobuf:"bytes,20,opt,name=idforad" json:"idforad,omitempty"`
	// Android Advertising ID, etc)
	AndroididMd5   *string `protobuf:"bytes,21,opt,name=androidid_md5" json:"androidid_md5,omitempty"`
	AndroididSha1  *string `protobuf:"bytes,22,opt,name=androidid_sha1" json:"androidid_sha1,omitempty"`
	MacaddressMd5  *string `protobuf:"bytes,23,opt,name=macaddress_md5" json:"macaddress_md5,omitempty"`
	MacaddressSha1 *string `protobuf:"bytes,24,opt,name=macaddress_sha1" json:"macaddress_sha1,omitempty"`
	IdforadEnabled *bool   `protobuf:"varint,25,opt,name=idforad_enabled" json:"idforad_enabled,omitempty"`
	// has tracking on or off
	Category         *string `protobuf:"bytes,26,opt,name=category" json:"category,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Device) Reset()         { *m = Device{} }
func (m *Device) String() string { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()    {}

func (m *Device) GetDidsha1() string {
	if m != nil && m.Didsha1 != nil {
		return *m.Didsha1
	}
	return ""
}

func (m *Device) GetDnt() int32 {
	if m != nil && m.Dnt != nil {
		return *m.Dnt
	}
	return 0
}

func (m *Device) GetUa() string {
	if m != nil && m.Ua != nil {
		return *m.Ua
	}
	return ""
}

func (m *Device) GetIp() string {
	if m != nil && m.Ip != nil {
		return *m.Ip
	}
	return ""
}

func (m *Device) GetCarrier() string {
	if m != nil && m.Carrier != nil {
		return *m.Carrier
	}
	return ""
}

func (m *Device) GetOs() string {
	if m != nil && m.Os != nil {
		return *m.Os
	}
	return ""
}

func (m *Device) GetOsv() string {
	if m != nil && m.Osv != nil {
		return *m.Osv
	}
	return ""
}

func (m *Device) GetLanguage() []string {
	if m != nil {
		return m.Language
	}
	return nil
}

func (m *Device) GetMake() string {
	if m != nil && m.Make != nil {
		return *m.Make
	}
	return ""
}

func (m *Device) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

func (m *Device) GetConnectiontype() string {
	if m != nil && m.Connectiontype != nil {
		return *m.Connectiontype
	}
	return ""
}

func (m *Device) GetDeprecatedApi() string {
	if m != nil && m.DeprecatedApi != nil {
		return *m.DeprecatedApi
	}
	return ""
}

func (m *Device) GetGeo() *Geo {
	if m != nil {
		return m.Geo
	}
	return nil
}

func (m *Device) GetBrowser() string {
	if m != nil && m.Browser != nil {
		return *m.Browser
	}
	return ""
}

func (m *Device) GetBrowserVersion() string {
	if m != nil && m.BrowserVersion != nil {
		return *m.BrowserVersion
	}
	return ""
}

func (m *Device) GetApi() []int32 {
	if m != nil {
		return m.Api
	}
	return nil
}

func (m *Device) GetOdin1() string {
	if m != nil && m.Odin1 != nil {
		return *m.Odin1
	}
	return ""
}

func (m *Device) GetOpenudid() string {
	if m != nil && m.Openudid != nil {
		return *m.Openudid
	}
	return ""
}

func (m *Device) GetSecureudid() string {
	if m != nil && m.Secureudid != nil {
		return *m.Secureudid
	}
	return ""
}

func (m *Device) GetIdforad() string {
	if m != nil && m.Idforad != nil {
		return *m.Idforad
	}
	return ""
}

func (m *Device) GetAndroididMd5() string {
	if m != nil && m.AndroididMd5 != nil {
		return *m.AndroididMd5
	}
	return ""
}

func (m *Device) GetAndroididSha1() string {
	if m != nil && m.AndroididSha1 != nil {
		return *m.AndroididSha1
	}
	return ""
}

func (m *Device) GetMacaddressMd5() string {
	if m != nil && m.MacaddressMd5 != nil {
		return *m.MacaddressMd5
	}
	return ""
}

func (m *Device) GetMacaddressSha1() string {
	if m != nil && m.MacaddressSha1 != nil {
		return *m.MacaddressSha1
	}
	return ""
}

func (m *Device) GetIdforadEnabled() bool {
	if m != nil && m.IdforadEnabled != nil {
		return *m.IdforadEnabled
	}
	return false
}

func (m *Device) GetCategory() string {
	if m != nil && m.Category != nil {
		return *m.Category
	}
	return ""
}

type User struct {
	Yob       *int32  `protobuf:"varint,1,opt,name=yob" json:"yob,omitempty"`
	Ethnicity *int32  `protobuf:"varint,2,opt,name=ethnicity" json:"ethnicity,omitempty"`
	Gender    *string `protobuf:"bytes,3,opt,name=gender" json:"gender,omitempty"`
	// or null for unknown).
	Income           *int32         `protobuf:"varint,4,opt,name=income" json:"income,omitempty"`
	Marital          *string        `protobuf:"bytes,5,opt,name=marital" json:"marital,omitempty"`
	Ext              []*ExtKeyValue `protobuf:"bytes,6,rep,name=ext" json:"ext,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}

func (m *User) GetYob() int32 {
	if m != nil && m.Yob != nil {
		return *m.Yob
	}
	return 0
}

func (m *User) GetEthnicity() int32 {
	if m != nil && m.Ethnicity != nil {
		return *m.Ethnicity
	}
	return 0
}

func (m *User) GetGender() string {
	if m != nil && m.Gender != nil {
		return *m.Gender
	}
	return ""
}

func (m *User) GetIncome() int32 {
	if m != nil && m.Income != nil {
		return *m.Income
	}
	return 0
}

func (m *User) GetMarital() string {
	if m != nil && m.Marital != nil {
		return *m.Marital
	}
	return ""
}

func (m *User) GetExt() []*ExtKeyValue {
	if m != nil {
		return m.Ext
	}
	return nil
}

type ThirdPartyKeyValue struct {
	Key              *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ThirdPartyKeyValue) Reset()         { *m = ThirdPartyKeyValue{} }
func (m *ThirdPartyKeyValue) String() string { return proto.CompactTextString(m) }
func (*ThirdPartyKeyValue) ProtoMessage()    {}

func (m *ThirdPartyKeyValue) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ThirdPartyKeyValue) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

type BidRequest struct {
	// OPENX identifiers
	ApiVersion *int32 `protobuf:"varint,1,opt,name=api_version" json:"api_version,omitempty"`
	// version of the API the
	// Market is using to
	// communicate with the
	// real-time bidder.
	AuctionId *string `protobuf:"bytes,2,opt,name=auction_id" json:"auction_id,omitempty"`
	// ADVERTISER identifiers
	MatchingAdIds []*AdId `protobuf:"bytes,3,rep,name=matching_ad_ids" json:"matching_ad_ids,omitempty"`
	// PUBLISHER identifiers
	PubWebsiteId *string `protobuf:"bytes,4,opt,name=pub_website_id" json:"pub_website_id,omitempty"`
	// AD size
	AdHeight *int32 `protobuf:"varint,5,opt,name=ad_height" json:"ad_height,omitempty"`
	// position to fill
	AdWidth *int32 `protobuf:"varint,6,opt,name=ad_width" json:"ad_width,omitempty"`
	// USER related fields
	UserCookieId *string `protobuf:"bytes,7,opt,name=user_cookie_id" json:"user_cookie_id,omitempty"`
	// user.  To protect the user's
	// identity this value is
	// different for each bidder.
	UserIpAddress    []byte `protobuf:"bytes,8,opt,name=user_ip_address" json:"user_ip_address,omitempty"`
	UserScreenHeight *int32 `protobuf:"varint,9,opt,name=user_screen_height" json:"user_screen_height,omitempty"`
	// user's screen
	UserScreenWidth *int32 `protobuf:"varint,10,opt,name=user_screen_width" json:"user_screen_width,omitempty"`
	// user's screen
	UserGeoCountry *string `protobuf:"bytes,11,opt,name=user_geo_country" json:"user_geo_country,omitempty"`
	UserGeoState   *string `protobuf:"bytes,12,opt,name=user_geo_state" json:"user_geo_state,omitempty"`
	UserGeoDma     *int32  `protobuf:"varint,13,opt,name=user_geo_dma" json:"user_geo_dma,omitempty"`
	UserAgent      *string `protobuf:"bytes,14,opt,name=user_agent" json:"user_agent,omitempty"`
	// and operating system.
	UserLang []string `protobuf:"bytes,15,rep,name=user_lang" json:"user_lang,omitempty"`
	// PUBLISHER related fields
	Url *string `protobuf:"bytes,16,opt,name=url" json:"url,omitempty"`
	// coming from.
	HttpReferer *string `protobuf:"bytes,17,opt,name=http_referer" json:"http_referer,omitempty"`
	// page generating the ad
	// request
	OxCatTier_1 *int32 `protobuf:"varint,18,opt,name=ox_cat_tier_1" json:"ox_cat_tier_1,omitempty"`
	// the page's content.
	OxCatTier_2 *int32 `protobuf:"varint,19,opt,name=ox_cat_tier_2" json:"ox_cat_tier_2,omitempty"`
	// the page's content.
	PubBlockedCat []int32 `protobuf:"varint,20,rep,name=pub_blocked_cat" json:"pub_blocked_cat,omitempty"`
	// publisher on this request
	PubBlockedContent []int32 `protobuf:"varint,21,rep,name=pub_blocked_content" json:"pub_blocked_content,omitempty"`
	// publisher on this request
	PubBlockedType []int32 `protobuf:"varint,22,rep,name=pub_blocked_type" json:"pub_blocked_type,omitempty"`
	// publisher on this request
	PubBlockedUrl []string `protobuf:"bytes,23,rep,name=pub_blocked_url" json:"pub_blocked_url,omitempty"`
	// from the ad's click URL on
	// this request.
	RtbData               *string  `protobuf:"bytes,24,opt,name=rtb_data" json:"rtb_data,omitempty"`
	PubBlockedAdLanguages []string `protobuf:"bytes,25,rep,name=pub_blocked_ad_languages" json:"pub_blocked_ad_languages,omitempty"`
	MarketOperator        *string  `protobuf:"bytes,26,opt,name=market_operator" json:"market_operator,omitempty"`
	Device                *Device  `protobuf:"bytes,27,opt,name=device" json:"device,omitempty"`
	IsTest                *bool    `protobuf:"varint,28,opt,name=is_test" json:"is_test,omitempty"`
	// Bidders are expected to return
	// responses in valid format, which
	// will be used for validation only
	// and get discarded.
	IsMobileSite       *bool                 `protobuf:"varint,29,opt,name=is_mobile_site" json:"is_mobile_site,omitempty"`
	IsApplication      *bool                 `protobuf:"varint,30,opt,name=is_application" json:"is_application,omitempty"`
	TpKeyVal           []*ThirdPartyKeyValue `protobuf:"bytes,31,rep,name=tp_key_val" json:"tp_key_val,omitempty"`
	ImplementationType *string               `protobuf:"bytes,32,opt,name=implementation_type" json:"implementation_type,omitempty"`
	SslEnabled         *bool                 `protobuf:"varint,33,opt,name=ssl_enabled" json:"ssl_enabled,omitempty"`
	User               *User                 `protobuf:"bytes,34,opt,name=user" json:"user,omitempty"`
	PubAdUnitId        *string               `protobuf:"bytes,35,opt,name=pub_ad_unit_id" json:"pub_ad_unit_id,omitempty"`
	Video              *Video                `protobuf:"bytes,36,opt,name=video" json:"video,omitempty"`
	App                *App                  `protobuf:"bytes,37,opt,name=app" json:"app,omitempty"`
	Site               *Site                 `protobuf:"bytes,38,opt,name=site" json:"site,omitempty"`
	XXX_unrecognized   []byte                `json:"-"`
}

func (m *BidRequest) Reset()         { *m = BidRequest{} }
func (m *BidRequest) String() string { return proto.CompactTextString(m) }
func (*BidRequest) ProtoMessage()    {}

func (m *BidRequest) GetApiVersion() int32 {
	if m != nil && m.ApiVersion != nil {
		return *m.ApiVersion
	}
	return 0
}

func (m *BidRequest) GetAuctionId() string {
	if m != nil && m.AuctionId != nil {
		return *m.AuctionId
	}
	return ""
}

func (m *BidRequest) GetMatchingAdIds() []*AdId {
	if m != nil {
		return m.MatchingAdIds
	}
	return nil
}

func (m *BidRequest) GetPubWebsiteId() string {
	if m != nil && m.PubWebsiteId != nil {
		return *m.PubWebsiteId
	}
	return ""
}

func (m *BidRequest) GetAdHeight() int32 {
	if m != nil && m.AdHeight != nil {
		return *m.AdHeight
	}
	return 0
}

func (m *BidRequest) GetAdWidth() int32 {
	if m != nil && m.AdWidth != nil {
		return *m.AdWidth
	}
	return 0
}

func (m *BidRequest) GetUserCookieId() string {
	if m != nil && m.UserCookieId != nil {
		return *m.UserCookieId
	}
	return ""
}

func (m *BidRequest) GetUserIpAddress() []byte {
	if m != nil {
		return m.UserIpAddress
	}
	return nil
}

func (m *BidRequest) GetUserScreenHeight() int32 {
	if m != nil && m.UserScreenHeight != nil {
		return *m.UserScreenHeight
	}
	return 0
}

func (m *BidRequest) GetUserScreenWidth() int32 {
	if m != nil && m.UserScreenWidth != nil {
		return *m.UserScreenWidth
	}
	return 0
}

func (m *BidRequest) GetUserGeoCountry() string {
	if m != nil && m.UserGeoCountry != nil {
		return *m.UserGeoCountry
	}
	return ""
}

func (m *BidRequest) GetUserGeoState() string {
	if m != nil && m.UserGeoState != nil {
		return *m.UserGeoState
	}
	return ""
}

func (m *BidRequest) GetUserGeoDma() int32 {
	if m != nil && m.UserGeoDma != nil {
		return *m.UserGeoDma
	}
	return 0
}

func (m *BidRequest) GetUserAgent() string {
	if m != nil && m.UserAgent != nil {
		return *m.UserAgent
	}
	return ""
}

func (m *BidRequest) GetUserLang() []string {
	if m != nil {
		return m.UserLang
	}
	return nil
}

func (m *BidRequest) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *BidRequest) GetHttpReferer() string {
	if m != nil && m.HttpReferer != nil {
		return *m.HttpReferer
	}
	return ""
}

func (m *BidRequest) GetOxCatTier_1() int32 {
	if m != nil && m.OxCatTier_1 != nil {
		return *m.OxCatTier_1
	}
	return 0
}

func (m *BidRequest) GetOxCatTier_2() int32 {
	if m != nil && m.OxCatTier_2 != nil {
		return *m.OxCatTier_2
	}
	return 0
}

func (m *BidRequest) GetPubBlockedCat() []int32 {
	if m != nil {
		return m.PubBlockedCat
	}
	return nil
}

func (m *BidRequest) GetPubBlockedContent() []int32 {
	if m != nil {
		return m.PubBlockedContent
	}
	return nil
}

func (m *BidRequest) GetPubBlockedType() []int32 {
	if m != nil {
		return m.PubBlockedType
	}
	return nil
}

func (m *BidRequest) GetPubBlockedUrl() []string {
	if m != nil {
		return m.PubBlockedUrl
	}
	return nil
}

func (m *BidRequest) GetRtbData() string {
	if m != nil && m.RtbData != nil {
		return *m.RtbData
	}
	return ""
}

func (m *BidRequest) GetPubBlockedAdLanguages() []string {
	if m != nil {
		return m.PubBlockedAdLanguages
	}
	return nil
}

func (m *BidRequest) GetMarketOperator() string {
	if m != nil && m.MarketOperator != nil {
		return *m.MarketOperator
	}
	return ""
}

func (m *BidRequest) GetDevice() *Device {
	if m != nil {
		return m.Device
	}
	return nil
}

func (m *BidRequest) GetIsTest() bool {
	if m != nil && m.IsTest != nil {
		return *m.IsTest
	}
	return false
}

func (m *BidRequest) GetIsMobileSite() bool {
	if m != nil && m.IsMobileSite != nil {
		return *m.IsMobileSite
	}
	return false
}

func (m *BidRequest) GetIsApplication() bool {
	if m != nil && m.IsApplication != nil {
		return *m.IsApplication
	}
	return false
}

func (m *BidRequest) GetTpKeyVal() []*ThirdPartyKeyValue {
	if m != nil {
		return m.TpKeyVal
	}
	return nil
}

func (m *BidRequest) GetImplementationType() string {
	if m != nil && m.ImplementationType != nil {
		return *m.ImplementationType
	}
	return ""
}

func (m *BidRequest) GetSslEnabled() bool {
	if m != nil && m.SslEnabled != nil {
		return *m.SslEnabled
	}
	return false
}

func (m *BidRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *BidRequest) GetPubAdUnitId() string {
	if m != nil && m.PubAdUnitId != nil {
		return *m.PubAdUnitId
	}
	return ""
}

func (m *BidRequest) GetVideo() *Video {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *BidRequest) GetApp() *App {
	if m != nil {
		return m.App
	}
	return nil
}

func (m *BidRequest) GetSite() *Site {
	if m != nil {
		return m.Site
	}
	return nil
}

type BidResponse struct {
	// OPENX identifiers
	ApiVersion *int32 `protobuf:"varint,1,req,name=api_version" json:"api_version,omitempty"`
	// of the API the Market is using
	// to communicate with the real-time
	// bidder.
	// NOTE: this should match the
	// version in the BidRequest
	AuctionId *string `protobuf:"bytes,2,req,name=auction_id" json:"auction_id,omitempty"`
	// deprecated, should be in Bid sub-message, see documentation for details
	DEPRECATEDMatchingAdId     *AdId    `protobuf:"bytes,3,opt,name=DEPRECATED_matching_ad_id" json:"DEPRECATED_matching_ad_id,omitempty"`
	DEPRECATEDCpmBidMicros     *int64   `protobuf:"varint,4,opt,name=DEPRECATED_cpm_bid_micros" json:"DEPRECATED_cpm_bid_micros,omitempty"`
	DEPRECATEDAdCode           *string  `protobuf:"bytes,5,opt,name=DEPRECATED_ad_code" json:"DEPRECATED_ad_code,omitempty"`
	DEPRECATEDClickUrl         *string  `protobuf:"bytes,6,opt,name=DEPRECATED_click_url" json:"DEPRECATED_click_url,omitempty"`
	DEPRECATEDAdvertiserId     *string  `protobuf:"bytes,7,opt,name=DEPRECATED_advertiser_id" json:"DEPRECATED_advertiser_id,omitempty"`
	DEPRECATEDAdOxCats         []int32  `protobuf:"varint,8,rep,name=DEPRECATED_ad_ox_cats" json:"DEPRECATED_ad_ox_cats,omitempty"`
	DEPRECATEDClickThroughUrls []string `protobuf:"bytes,9,rep,name=DEPRECATED_click_through_urls" json:"DEPRECATED_click_through_urls,omitempty"`
	DEPRECATEDBuyerId          *string  `protobuf:"bytes,10,opt,name=DEPRECATED_buyer_id" json:"DEPRECATED_buyer_id,omitempty"`
	DEPRECATEDBrandId          *string  `protobuf:"bytes,11,opt,name=DEPRECATED_brand_id" json:"DEPRECATED_brand_id,omitempty"`
	// ------------------------------------------------------------------------
	// ***    OPTIONAL FIELDS                                               ***
	// ------------------------------------------------------------------------
	// These fields are optional and may be set by the bidder.
	Bids []*Bid `protobuf:"bytes,12,rep,name=bids" json:"bids,omitempty"`
	// auction
	NextHighestBidMicros *int64 `protobuf:"varint,13,opt,name=next_highest_bid_micros" json:"next_highest_bid_micros,omitempty"`
	XXX_unrecognized     []byte `json:"-"`
}

func (m *BidResponse) Reset()         { *m = BidResponse{} }
func (m *BidResponse) String() string { return proto.CompactTextString(m) }
func (*BidResponse) ProtoMessage()    {}

func (m *BidResponse) GetApiVersion() int32 {
	if m != nil && m.ApiVersion != nil {
		return *m.ApiVersion
	}
	return 0
}

func (m *BidResponse) GetAuctionId() string {
	if m != nil && m.AuctionId != nil {
		return *m.AuctionId
	}
	return ""
}

func (m *BidResponse) GetDEPRECATEDMatchingAdId() *AdId {
	if m != nil {
		return m.DEPRECATEDMatchingAdId
	}
	return nil
}

func (m *BidResponse) GetDEPRECATEDCpmBidMicros() int64 {
	if m != nil && m.DEPRECATEDCpmBidMicros != nil {
		return *m.DEPRECATEDCpmBidMicros
	}
	return 0
}

func (m *BidResponse) GetDEPRECATEDAdCode() string {
	if m != nil && m.DEPRECATEDAdCode != nil {
		return *m.DEPRECATEDAdCode
	}
	return ""
}

func (m *BidResponse) GetDEPRECATEDClickUrl() string {
	if m != nil && m.DEPRECATEDClickUrl != nil {
		return *m.DEPRECATEDClickUrl
	}
	return ""
}

func (m *BidResponse) GetDEPRECATEDAdvertiserId() string {
	if m != nil && m.DEPRECATEDAdvertiserId != nil {
		return *m.DEPRECATEDAdvertiserId
	}
	return ""
}

func (m *BidResponse) GetDEPRECATEDAdOxCats() []int32 {
	if m != nil {
		return m.DEPRECATEDAdOxCats
	}
	return nil
}

func (m *BidResponse) GetDEPRECATEDClickThroughUrls() []string {
	if m != nil {
		return m.DEPRECATEDClickThroughUrls
	}
	return nil
}

func (m *BidResponse) GetDEPRECATEDBuyerId() string {
	if m != nil && m.DEPRECATEDBuyerId != nil {
		return *m.DEPRECATEDBuyerId
	}
	return ""
}

func (m *BidResponse) GetDEPRECATEDBrandId() string {
	if m != nil && m.DEPRECATEDBrandId != nil {
		return *m.DEPRECATEDBrandId
	}
	return ""
}

func (m *BidResponse) GetBids() []*Bid {
	if m != nil {
		return m.Bids
	}
	return nil
}

func (m *BidResponse) GetNextHighestBidMicros() int64 {
	if m != nil && m.NextHighestBidMicros != nil {
		return *m.NextHighestBidMicros
	}
	return 0
}

type Bid struct {
	// ------------------------------------------------------------------------
	// ***    REQUIRED FIELDS                                               ***
	// ------------------------------------------------------------------------
	// these fields must be passed with a valid bid
	MatchingAdId *AdId `protobuf:"bytes,1,req,name=matching_ad_id" json:"matching_ad_id,omitempty"`
	// selected
	CpmBidMicros *int64 `protobuf:"varint,2,req,name=cpm_bid_micros" json:"cpm_bid_micros,omitempty"`
	// Bids must be made in billable
	// units (so for USD they must be
	// multiples of 10,000).
	AdCode           *string  `protobuf:"bytes,3,req,name=ad_code" json:"ad_code,omitempty"`
	AdOxCats         []int32  `protobuf:"varint,4,rep,name=ad_ox_cats" json:"ad_ox_cats,omitempty"`
	ClickThroughUrls []string `protobuf:"bytes,5,rep,name=click_through_urls" json:"click_through_urls,omitempty"`
	BuyerId          *string  `protobuf:"bytes,6,opt,name=buyer_id" json:"buyer_id,omitempty"`
	// customer in their system (which is
	// often a network or agency).
	BrandId *string `protobuf:"bytes,7,opt,name=brand_id" json:"brand_id,omitempty"`
	// whose ad will show.
	Crid             *string `protobuf:"bytes,8,opt,name=crid" json:"crid,omitempty"`
	CanPassback      *bool   `protobuf:"varint,9,opt,name=can_passback" json:"can_passback,omitempty"`
	AgencyId         *string `protobuf:"bytes,10,opt,name=agency_id" json:"agency_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Bid) Reset()         { *m = Bid{} }
func (m *Bid) String() string { return proto.CompactTextString(m) }
func (*Bid) ProtoMessage()    {}

func (m *Bid) GetMatchingAdId() *AdId {
	if m != nil {
		return m.MatchingAdId
	}
	return nil
}

func (m *Bid) GetCpmBidMicros() int64 {
	if m != nil && m.CpmBidMicros != nil {
		return *m.CpmBidMicros
	}
	return 0
}

func (m *Bid) GetAdCode() string {
	if m != nil && m.AdCode != nil {
		return *m.AdCode
	}
	return ""
}

func (m *Bid) GetAdOxCats() []int32 {
	if m != nil {
		return m.AdOxCats
	}
	return nil
}

func (m *Bid) GetClickThroughUrls() []string {
	if m != nil {
		return m.ClickThroughUrls
	}
	return nil
}

func (m *Bid) GetBuyerId() string {
	if m != nil && m.BuyerId != nil {
		return *m.BuyerId
	}
	return ""
}

func (m *Bid) GetBrandId() string {
	if m != nil && m.BrandId != nil {
		return *m.BrandId
	}
	return ""
}

func (m *Bid) GetCrid() string {
	if m != nil && m.Crid != nil {
		return *m.Crid
	}
	return ""
}

func (m *Bid) GetCanPassback() bool {
	if m != nil && m.CanPassback != nil {
		return *m.CanPassback
	}
	return false
}

func (m *Bid) GetAgencyId() string {
	if m != nil && m.AgencyId != nil {
		return *m.AgencyId
	}
	return ""
}

type AuctionResults struct {
	// OPENX identifiers
	ApiVersion *int32 `protobuf:"varint,1,req,name=api_version" json:"api_version,omitempty"`
	// version of the API the
	// Market is using to
	// communicate with the
	// real-time bidder.
	AuctionId *string `protobuf:"bytes,2,req,name=auction_id" json:"auction_id,omitempty"`
	// generated by the Market
	// and used to identify the
	// auction request.
	Results          []*AuctionResult `protobuf:"bytes,3,rep,name=results" json:"results,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *AuctionResults) Reset()         { *m = AuctionResults{} }
func (m *AuctionResults) String() string { return proto.CompactTextString(m) }
func (*AuctionResults) ProtoMessage()    {}

func (m *AuctionResults) GetApiVersion() int32 {
	if m != nil && m.ApiVersion != nil {
		return *m.ApiVersion
	}
	return 0
}

func (m *AuctionResults) GetAuctionId() string {
	if m != nil && m.AuctionId != nil {
		return *m.AuctionId
	}
	return ""
}

func (m *AuctionResults) GetResults() []*AuctionResult {
	if m != nil {
		return m.Results
	}
	return nil
}

type AuctionResult struct {
	MatchingAdId *AdId          `protobuf:"bytes,1,req,name=matching_ad_id" json:"matching_ad_id,omitempty"`
	Status       *AuctionStatus `protobuf:"varint,2,req,name=status,enum=AuctionStatus" json:"status,omitempty"`
	LossReason   *string        `protobuf:"bytes,3,opt,name=loss_reason" json:"loss_reason,omitempty"`
	// example, "price",
	// "disqualification"
	// see documentation for more
	ErrorReason *string `protobuf:"bytes,4,opt,name=error_reason" json:"error_reason,omitempty"`
	// for example, "timeout"
	WinningBidMicros    *int64 `protobuf:"varint,5,opt,name=winning_bid_micros" json:"winning_bid_micros,omitempty"`
	ClearingPriceMicros *int64 `protobuf:"varint,6,opt,name=clearing_price_micros" json:"clearing_price_micros,omitempty"`
	XXX_unrecognized    []byte `json:"-"`
}

func (m *AuctionResult) Reset()         { *m = AuctionResult{} }
func (m *AuctionResult) String() string { return proto.CompactTextString(m) }
func (*AuctionResult) ProtoMessage()    {}

func (m *AuctionResult) GetMatchingAdId() *AdId {
	if m != nil {
		return m.MatchingAdId
	}
	return nil
}

func (m *AuctionResult) GetStatus() AuctionStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return AuctionStatus_win
}

func (m *AuctionResult) GetLossReason() string {
	if m != nil && m.LossReason != nil {
		return *m.LossReason
	}
	return ""
}

func (m *AuctionResult) GetErrorReason() string {
	if m != nil && m.ErrorReason != nil {
		return *m.ErrorReason
	}
	return ""
}

func (m *AuctionResult) GetWinningBidMicros() int64 {
	if m != nil && m.WinningBidMicros != nil {
		return *m.WinningBidMicros
	}
	return 0
}

func (m *AuctionResult) GetClearingPriceMicros() int64 {
	if m != nil && m.ClearingPriceMicros != nil {
		return *m.ClearingPriceMicros
	}
	return 0
}

// The publisher object corresponding to OpenRtb spec 2.3 (sec 3.2.8).
type Publisher struct {
	Id               *string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Publisher) Reset()         { *m = Publisher{} }
func (m *Publisher) String() string { return proto.CompactTextString(m) }
func (*Publisher) ProtoMessage()    {}

func (m *Publisher) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func init() {
	proto.RegisterEnum("DealPricingType", DealPricingType_name, DealPricingType_value)
	proto.RegisterEnum("DealExclusivity", DealExclusivity_name, DealExclusivity_value)
	proto.RegisterEnum("AuctionStatus", AuctionStatus_name, AuctionStatus_value)
	proto.RegisterEnum("Video_VideoLinearity", Video_VideoLinearity_name, Video_VideoLinearity_value)
	proto.RegisterEnum("Video_VideoBidResponseProtocol", Video_VideoBidResponseProtocol_name, Video_VideoBidResponseProtocol_value)
}
func (m *ExtKeyValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Deal) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DealId = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealCpmMicros", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DealCpmMicros = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealPricingType", wireType)
			}
			var v DealPricingType
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (DealPricingType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DealPricingType = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DealExclusivity", wireType)
			}
			var v DealExclusivity
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (DealExclusivity(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DealExclusivity = &v
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *App) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bundle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Bundle = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publisher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Publisher == nil {
				m.Publisher = &Publisher{}
			}
			if err := m.Publisher.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Site) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publisher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Publisher == nil {
				m.Publisher = &Publisher{}
			}
			if err := m.Publisher.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Video) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mimes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mimes = append(m.Mimes, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Linearity", wireType)
			}
			var v Video_VideoLinearity
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (Video_VideoLinearity(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Linearity = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minduration", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Minduration = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maxduration", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Maxduration = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var v Video_VideoBidResponseProtocol
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (Video_VideoBidResponseProtocol(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Protocol = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Startdelay", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Startdelay = &v
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *AdId) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CampaignId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PlacementId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreativeId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreativeId = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedDealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DeprecatedDealId = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdHeight", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdHeight = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdWidth", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdWidth = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Deal == nil {
				m.Deal = &Deal{}
			}
			if err := m.Deal.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EligibleDeals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EligibleDeals = append(m.EligibleDeals, &Deal{})
			if err := m.EligibleDeals[len(m.EligibleDeals)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	return nil
}
func (m *Geo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			v2 := float32(math.Float32frombits(v))
			m.Lat = &v2
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lon", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			v2 := float32(math.Float32frombits(v))
			m.Lon = &v2
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Country = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.City = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Zip = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Continent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Continent = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.State = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dma", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dma = &v
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *Device) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Didsha1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Didsha1 = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dnt", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dnt = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ua", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Ua = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Ip = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Carrier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Carrier = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Os = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Osv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Osv = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = append(m.Language, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Make", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Make = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Model = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connectiontype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Connectiontype = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedApi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DeprecatedApi = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Geo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Geo == nil {
				m.Geo = &Geo{}
			}
			if err := m.Geo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Browser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Browser = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrowserVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.BrowserVersion = &s
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Api", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Api = append(m.Api, v)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Odin1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Odin1 = &s
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Openudid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Openudid = &s
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secureudid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Secureudid = &s
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idforad", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Idforad = &s
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroididMd5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.AndroididMd5 = &s
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroididSha1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.AndroididSha1 = &s
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacaddressMd5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.MacaddressMd5 = &s
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MacaddressSha1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.MacaddressSha1 = &s
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdforadEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IdforadEnabled = &b
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Category = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *User) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yob", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Yob = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ethnicity", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ethnicity = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Gender = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Income", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Income = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Marital", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Marital = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = append(m.Ext, &ExtKeyValue{})
			if err := m.Ext[len(m.Ext)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ThirdPartyKeyValue) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Value = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *BidRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ApiVersion = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.AuctionId = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchingAdIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchingAdIds = append(m.MatchingAdIds, &AdId{})
			if err := m.MatchingAdIds[len(m.MatchingAdIds)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubWebsiteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.PubWebsiteId = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdHeight", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdHeight = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdWidth", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdWidth = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserCookieId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.UserCookieId = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIpAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIpAddress = append([]byte{}, data[iNdEx:postIndex]...)
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserScreenHeight", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserScreenHeight = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserScreenWidth", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserScreenWidth = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGeoCountry", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.UserGeoCountry = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGeoState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.UserGeoState = &s
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserGeoDma", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UserGeoDma = &v
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.UserAgent = &s
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserLang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserLang = append(m.UserLang, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Url = &s
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpReferer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.HttpReferer = &s
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OxCatTier_1", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OxCatTier_1 = &v
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OxCatTier_2", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OxCatTier_2 = &v
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubBlockedCat", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PubBlockedCat = append(m.PubBlockedCat, v)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubBlockedContent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PubBlockedContent = append(m.PubBlockedContent, v)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubBlockedType", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PubBlockedType = append(m.PubBlockedType, v)
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubBlockedUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubBlockedUrl = append(m.PubBlockedUrl, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RtbData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.RtbData = &s
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubBlockedAdLanguages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubBlockedAdLanguages = append(m.PubBlockedAdLanguages, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketOperator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.MarketOperator = &s
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Device == nil {
				m.Device = &Device{}
			}
			if err := m.Device.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsTest = &b
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMobileSite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsMobileSite = &b
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsApplication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsApplication = &b
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TpKeyVal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TpKeyVal = append(m.TpKeyVal, &ThirdPartyKeyValue{})
			if err := m.TpKeyVal[len(m.TpKeyVal)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImplementationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ImplementationType = &s
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SslEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SslEnabled = &b
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubAdUnitId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.PubAdUnitId = &s
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &Video{}
			}
			if err := m.Video.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &App{}
			}
			if err := m.App.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Site", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Site == nil {
				m.Site = &Site{}
			}
			if err := m.Site.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *BidResponse) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ApiVersion = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.AuctionId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDMatchingAdId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DEPRECATEDMatchingAdId == nil {
				m.DEPRECATEDMatchingAdId = &AdId{}
			}
			if err := m.DEPRECATEDMatchingAdId.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDCpmBidMicros", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DEPRECATEDCpmBidMicros = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDAdCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DEPRECATEDAdCode = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDClickUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DEPRECATEDClickUrl = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDAdvertiserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DEPRECATEDAdvertiserId = &s
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDAdOxCats", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DEPRECATEDAdOxCats = append(m.DEPRECATEDAdOxCats, v)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDClickThroughUrls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DEPRECATEDClickThroughUrls = append(m.DEPRECATEDClickThroughUrls, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDBuyerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DEPRECATEDBuyerId = &s
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DEPRECATEDBrandId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.DEPRECATEDBrandId = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bids = append(m.Bids, &Bid{})
			if err := m.Bids[len(m.Bids)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextHighestBidMicros", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NextHighestBidMicros = &v
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	return nil
}
func (m *Bid) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchingAdId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchingAdId == nil {
				m.MatchingAdId = &AdId{}
			}
			if err := m.MatchingAdId.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpmBidMicros", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CpmBidMicros = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.AdCode = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdOxCats", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdOxCats = append(m.AdOxCats, v)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClickThroughUrls", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClickThroughUrls = append(m.ClickThroughUrls, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.BuyerId = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrandId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.BrandId = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Crid = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanPassback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CanPassback = &b
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgencyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.AgencyId = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	return nil
}
func (m *AuctionResults) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ApiVersion = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.AuctionId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &AuctionResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	return nil
}
func (m *AuctionResult) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchingAdId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if msglen < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchingAdId == nil {
				m.MatchingAdId = &AdId{}
			}
			if err := m.MatchingAdId.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v AuctionStatus
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (AuctionStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LossReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.LossReason = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ErrorReason = &s
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinningBidMicros", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WinningBidMicros = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearingPriceMicros", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearingPriceMicros = &v
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	return nil
}
func (m *Publisher) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOpenxRtb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOpenxRtb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func skipOpenxRtb(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOpenxRtb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOpenxRtb(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOpenxRtb = fmt.Errorf("proto: negative length found during unmarshaling")
)

func (m *ExtKeyValue) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deal) Size() (n int) {
	var l int
	_ = l
	if m.DealId != nil {
		l = len(*m.DealId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.DealCpmMicros != nil {
		n += 1 + sovOpenxRtb(uint64(*m.DealCpmMicros))
	}
	if m.DealPricingType != nil {
		n += 1 + sovOpenxRtb(uint64(*m.DealPricingType))
	}
	if m.DealExclusivity != nil {
		n += 1 + sovOpenxRtb(uint64(*m.DealExclusivity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *App) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Bundle != nil {
		l = len(*m.Bundle)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Publisher != nil {
		l = m.Publisher.Size()
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Site) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Publisher != nil {
		l = m.Publisher.Size()
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Video) Size() (n int) {
	var l int
	_ = l
	if len(m.Mimes) > 0 {
		for _, s := range m.Mimes {
			l = len(s)
			n += 1 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.Linearity != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Linearity))
	}
	if m.Minduration != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Minduration))
	}
	if m.Maxduration != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Maxduration))
	}
	if m.Protocol != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Protocol))
	}
	if m.Startdelay != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Startdelay))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdId) Size() (n int) {
	var l int
	_ = l
	if m.CampaignId != nil {
		n += 1 + sovOpenxRtb(uint64(*m.CampaignId))
	}
	if m.PlacementId != nil {
		n += 1 + sovOpenxRtb(uint64(*m.PlacementId))
	}
	if m.CreativeId != nil {
		n += 1 + sovOpenxRtb(uint64(*m.CreativeId))
	}
	if m.DeprecatedDealId != nil {
		l = len(*m.DeprecatedDealId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.AdHeight != nil {
		n += 1 + sovOpenxRtb(uint64(*m.AdHeight))
	}
	if m.AdWidth != nil {
		n += 1 + sovOpenxRtb(uint64(*m.AdWidth))
	}
	if m.Deal != nil {
		l = m.Deal.Size()
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if len(m.EligibleDeals) > 0 {
		for _, e := range m.EligibleDeals {
			l = e.Size()
			n += 1 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Geo) Size() (n int) {
	var l int
	_ = l
	if m.Lat != nil {
		n += 5
	}
	if m.Lon != nil {
		n += 5
	}
	if m.Country != nil {
		l = len(*m.Country)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.City != nil {
		l = len(*m.City)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Zip != nil {
		l = len(*m.Zip)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Type))
	}
	if m.Continent != nil {
		l = len(*m.Continent)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.State != nil {
		l = len(*m.State)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Dma != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Dma))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Device) Size() (n int) {
	var l int
	_ = l
	if m.Didsha1 != nil {
		l = len(*m.Didsha1)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Dnt != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Dnt))
	}
	if m.Ua != nil {
		l = len(*m.Ua)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Ip != nil {
		l = len(*m.Ip)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Carrier != nil {
		l = len(*m.Carrier)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Os != nil {
		l = len(*m.Os)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Osv != nil {
		l = len(*m.Osv)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if len(m.Language) > 0 {
		for _, s := range m.Language {
			l = len(s)
			n += 1 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.Make != nil {
		l = len(*m.Make)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Model != nil {
		l = len(*m.Model)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Connectiontype != nil {
		l = len(*m.Connectiontype)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.DeprecatedApi != nil {
		l = len(*m.DeprecatedApi)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Geo != nil {
		l = m.Geo.Size()
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Browser != nil {
		l = len(*m.Browser)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.BrowserVersion != nil {
		l = len(*m.BrowserVersion)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if len(m.Api) > 0 {
		for _, e := range m.Api {
			n += 2 + sovOpenxRtb(uint64(e))
		}
	}
	if m.Odin1 != nil {
		l = len(*m.Odin1)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.Openudid != nil {
		l = len(*m.Openudid)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.Secureudid != nil {
		l = len(*m.Secureudid)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.Idforad != nil {
		l = len(*m.Idforad)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.AndroididMd5 != nil {
		l = len(*m.AndroididMd5)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.AndroididSha1 != nil {
		l = len(*m.AndroididSha1)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.MacaddressMd5 != nil {
		l = len(*m.MacaddressMd5)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.MacaddressSha1 != nil {
		l = len(*m.MacaddressSha1)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.IdforadEnabled != nil {
		n += 3
	}
	if m.Category != nil {
		l = len(*m.Category)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	if m.Yob != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Yob))
	}
	if m.Ethnicity != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Ethnicity))
	}
	if m.Gender != nil {
		l = len(*m.Gender)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Income != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Income))
	}
	if m.Marital != nil {
		l = len(*m.Marital)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if len(m.Ext) > 0 {
		for _, e := range m.Ext {
			l = e.Size()
			n += 1 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ThirdPartyKeyValue) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Value != nil {
		l = len(*m.Value)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidRequest) Size() (n int) {
	var l int
	_ = l
	if m.ApiVersion != nil {
		n += 1 + sovOpenxRtb(uint64(*m.ApiVersion))
	}
	if m.AuctionId != nil {
		l = len(*m.AuctionId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if len(m.MatchingAdIds) > 0 {
		for _, e := range m.MatchingAdIds {
			l = e.Size()
			n += 1 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.PubWebsiteId != nil {
		l = len(*m.PubWebsiteId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.AdHeight != nil {
		n += 1 + sovOpenxRtb(uint64(*m.AdHeight))
	}
	if m.AdWidth != nil {
		n += 1 + sovOpenxRtb(uint64(*m.AdWidth))
	}
	if m.UserCookieId != nil {
		l = len(*m.UserCookieId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.UserIpAddress != nil {
		l = len(m.UserIpAddress)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.UserScreenHeight != nil {
		n += 1 + sovOpenxRtb(uint64(*m.UserScreenHeight))
	}
	if m.UserScreenWidth != nil {
		n += 1 + sovOpenxRtb(uint64(*m.UserScreenWidth))
	}
	if m.UserGeoCountry != nil {
		l = len(*m.UserGeoCountry)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.UserGeoState != nil {
		l = len(*m.UserGeoState)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.UserGeoDma != nil {
		n += 1 + sovOpenxRtb(uint64(*m.UserGeoDma))
	}
	if m.UserAgent != nil {
		l = len(*m.UserAgent)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if len(m.UserLang) > 0 {
		for _, s := range m.UserLang {
			l = len(s)
			n += 1 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.Url != nil {
		l = len(*m.Url)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.HttpReferer != nil {
		l = len(*m.HttpReferer)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.OxCatTier_1 != nil {
		n += 2 + sovOpenxRtb(uint64(*m.OxCatTier_1))
	}
	if m.OxCatTier_2 != nil {
		n += 2 + sovOpenxRtb(uint64(*m.OxCatTier_2))
	}
	if len(m.PubBlockedCat) > 0 {
		for _, e := range m.PubBlockedCat {
			n += 2 + sovOpenxRtb(uint64(e))
		}
	}
	if len(m.PubBlockedContent) > 0 {
		for _, e := range m.PubBlockedContent {
			n += 2 + sovOpenxRtb(uint64(e))
		}
	}
	if len(m.PubBlockedType) > 0 {
		for _, e := range m.PubBlockedType {
			n += 2 + sovOpenxRtb(uint64(e))
		}
	}
	if len(m.PubBlockedUrl) > 0 {
		for _, s := range m.PubBlockedUrl {
			l = len(s)
			n += 2 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.RtbData != nil {
		l = len(*m.RtbData)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if len(m.PubBlockedAdLanguages) > 0 {
		for _, s := range m.PubBlockedAdLanguages {
			l = len(s)
			n += 2 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.MarketOperator != nil {
		l = len(*m.MarketOperator)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.Device != nil {
		l = m.Device.Size()
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.IsTest != nil {
		n += 3
	}
	if m.IsMobileSite != nil {
		n += 3
	}
	if m.IsApplication != nil {
		n += 3
	}
	if len(m.TpKeyVal) > 0 {
		for _, e := range m.TpKeyVal {
			l = e.Size()
			n += 2 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.ImplementationType != nil {
		l = len(*m.ImplementationType)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.SslEnabled != nil {
		n += 3
	}
	if m.User != nil {
		l = m.User.Size()
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.PubAdUnitId != nil {
		l = len(*m.PubAdUnitId)
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.App != nil {
		l = m.App.Size()
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.Site != nil {
		l = m.Site.Size()
		n += 2 + l + sovOpenxRtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BidResponse) Size() (n int) {
	var l int
	_ = l
	if m.ApiVersion != nil {
		n += 1 + sovOpenxRtb(uint64(*m.ApiVersion))
	}
	if m.AuctionId != nil {
		l = len(*m.AuctionId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.DEPRECATEDMatchingAdId != nil {
		l = m.DEPRECATEDMatchingAdId.Size()
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.DEPRECATEDCpmBidMicros != nil {
		n += 1 + sovOpenxRtb(uint64(*m.DEPRECATEDCpmBidMicros))
	}
	if m.DEPRECATEDAdCode != nil {
		l = len(*m.DEPRECATEDAdCode)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.DEPRECATEDClickUrl != nil {
		l = len(*m.DEPRECATEDClickUrl)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.DEPRECATEDAdvertiserId != nil {
		l = len(*m.DEPRECATEDAdvertiserId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if len(m.DEPRECATEDAdOxCats) > 0 {
		for _, e := range m.DEPRECATEDAdOxCats {
			n += 1 + sovOpenxRtb(uint64(e))
		}
	}
	if len(m.DEPRECATEDClickThroughUrls) > 0 {
		for _, s := range m.DEPRECATEDClickThroughUrls {
			l = len(s)
			n += 1 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.DEPRECATEDBuyerId != nil {
		l = len(*m.DEPRECATEDBuyerId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.DEPRECATEDBrandId != nil {
		l = len(*m.DEPRECATEDBrandId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if len(m.Bids) > 0 {
		for _, e := range m.Bids {
			l = e.Size()
			n += 1 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.NextHighestBidMicros != nil {
		n += 1 + sovOpenxRtb(uint64(*m.NextHighestBidMicros))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Bid) Size() (n int) {
	var l int
	_ = l
	if m.MatchingAdId != nil {
		l = m.MatchingAdId.Size()
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.CpmBidMicros != nil {
		n += 1 + sovOpenxRtb(uint64(*m.CpmBidMicros))
	}
	if m.AdCode != nil {
		l = len(*m.AdCode)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if len(m.AdOxCats) > 0 {
		for _, e := range m.AdOxCats {
			n += 1 + sovOpenxRtb(uint64(e))
		}
	}
	if len(m.ClickThroughUrls) > 0 {
		for _, s := range m.ClickThroughUrls {
			l = len(s)
			n += 1 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.BuyerId != nil {
		l = len(*m.BuyerId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.BrandId != nil {
		l = len(*m.BrandId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Crid != nil {
		l = len(*m.Crid)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.CanPassback != nil {
		n += 2
	}
	if m.AgencyId != nil {
		l = len(*m.AgencyId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuctionResults) Size() (n int) {
	var l int
	_ = l
	if m.ApiVersion != nil {
		n += 1 + sovOpenxRtb(uint64(*m.ApiVersion))
	}
	if m.AuctionId != nil {
		l = len(*m.AuctionId)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovOpenxRtb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuctionResult) Size() (n int) {
	var l int
	_ = l
	if m.MatchingAdId != nil {
		l = m.MatchingAdId.Size()
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.Status != nil {
		n += 1 + sovOpenxRtb(uint64(*m.Status))
	}
	if m.LossReason != nil {
		l = len(*m.LossReason)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.ErrorReason != nil {
		l = len(*m.ErrorReason)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.WinningBidMicros != nil {
		n += 1 + sovOpenxRtb(uint64(*m.WinningBidMicros))
	}
	if m.ClearingPriceMicros != nil {
		n += 1 + sovOpenxRtb(uint64(*m.ClearingPriceMicros))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Publisher) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovOpenxRtb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovOpenxRtb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOpenxRtb(x uint64) (n int) {
	return sovOpenxRtb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ExtKeyValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ExtKeyValue) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Key)))
		i += copy(data[i:], *m.Key)
	}
	if m.Value != nil {
		data[i] = 0x12
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Value)))
		i += copy(data[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Deal) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Deal) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DealId != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.DealId)))
		i += copy(data[i:], *m.DealId)
	}
	if m.DealCpmMicros != nil {
		data[i] = 0x10
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.DealCpmMicros))
	}
	if m.DealPricingType != nil {
		data[i] = 0x18
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.DealPricingType))
	}
	if m.DealExclusivity != nil {
		data[i] = 0x20
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.DealExclusivity))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *App) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *App) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Id)))
		i += copy(data[i:], *m.Id)
	}
	if m.Name != nil {
		data[i] = 0x12
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Name)))
		i += copy(data[i:], *m.Name)
	}
	if m.Bundle != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Bundle)))
		i += copy(data[i:], *m.Bundle)
	}
	if m.Publisher != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.Publisher.Size()))
		n1, err := m.Publisher.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Site) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Site) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Id)))
		i += copy(data[i:], *m.Id)
	}
	if m.Publisher != nil {
		data[i] = 0x12
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.Publisher.Size()))
		n2, err := m.Publisher.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Video) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Video) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mimes) > 0 {
		for _, s := range m.Mimes {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Linearity != nil {
		data[i] = 0x10
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Linearity))
	}
	if m.Minduration != nil {
		data[i] = 0x18
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Minduration))
	}
	if m.Maxduration != nil {
		data[i] = 0x20
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Maxduration))
	}
	if m.Protocol != nil {
		data[i] = 0x28
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Protocol))
	}
	if m.Startdelay != nil {
		data[i] = 0x30
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Startdelay))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AdId) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AdId) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CampaignId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x8
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.CampaignId))
	}
	if m.PlacementId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x10
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.PlacementId))
	}
	if m.CreativeId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x18
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.CreativeId))
	}
	if m.DeprecatedDealId != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.DeprecatedDealId)))
		i += copy(data[i:], *m.DeprecatedDealId)
	}
	if m.AdHeight != nil {
		data[i] = 0x28
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.AdHeight))
	}
	if m.AdWidth != nil {
		data[i] = 0x30
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.AdWidth))
	}
	if m.Deal != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.Deal.Size()))
		n3, err := m.Deal.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.EligibleDeals) > 0 {
		for _, msg := range m.EligibleDeals {
			data[i] = 0x42
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Geo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Geo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lat != nil {
		data[i] = 0xd
		i++
		i = encodeFixed32OpenxRtb(data, i, uint32(math.Float32bits(*m.Lat)))
	}
	if m.Lon != nil {
		data[i] = 0x15
		i++
		i = encodeFixed32OpenxRtb(data, i, uint32(math.Float32bits(*m.Lon)))
	}
	if m.Country != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Country)))
		i += copy(data[i:], *m.Country)
	}
	if m.City != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.City)))
		i += copy(data[i:], *m.City)
	}
	if m.Zip != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Zip)))
		i += copy(data[i:], *m.Zip)
	}
	if m.Type != nil {
		data[i] = 0x30
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Type))
	}
	if m.Continent != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Continent)))
		i += copy(data[i:], *m.Continent)
	}
	if m.State != nil {
		data[i] = 0x42
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.State)))
		i += copy(data[i:], *m.State)
	}
	if m.Dma != nil {
		data[i] = 0x48
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Dma))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Device) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Device) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Didsha1 != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Didsha1)))
		i += copy(data[i:], *m.Didsha1)
	}
	if m.Dnt != nil {
		data[i] = 0x10
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Dnt))
	}
	if m.Ua != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Ua)))
		i += copy(data[i:], *m.Ua)
	}
	if m.Ip != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Ip)))
		i += copy(data[i:], *m.Ip)
	}
	if m.Carrier != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Carrier)))
		i += copy(data[i:], *m.Carrier)
	}
	if m.Os != nil {
		data[i] = 0x32
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Os)))
		i += copy(data[i:], *m.Os)
	}
	if m.Osv != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Osv)))
		i += copy(data[i:], *m.Osv)
	}
	if len(m.Language) > 0 {
		for _, s := range m.Language {
			data[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Make != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Make)))
		i += copy(data[i:], *m.Make)
	}
	if m.Model != nil {
		data[i] = 0x52
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Model)))
		i += copy(data[i:], *m.Model)
	}
	if m.Connectiontype != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Connectiontype)))
		i += copy(data[i:], *m.Connectiontype)
	}
	if m.DeprecatedApi != nil {
		data[i] = 0x62
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.DeprecatedApi)))
		i += copy(data[i:], *m.DeprecatedApi)
	}
	if m.Geo != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.Geo.Size()))
		n4, err := m.Geo.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Browser != nil {
		data[i] = 0x72
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Browser)))
		i += copy(data[i:], *m.Browser)
	}
	if m.BrowserVersion != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.BrowserVersion)))
		i += copy(data[i:], *m.BrowserVersion)
	}
	if len(m.Api) > 0 {
		for _, num := range m.Api {
			data[i] = 0x80
			i++
			data[i] = 0x1
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(num))
		}
	}
	if m.Odin1 != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Odin1)))
		i += copy(data[i:], *m.Odin1)
	}
	if m.Openudid != nil {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Openudid)))
		i += copy(data[i:], *m.Openudid)
	}
	if m.Secureudid != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Secureudid)))
		i += copy(data[i:], *m.Secureudid)
	}
	if m.Idforad != nil {
		data[i] = 0xa2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Idforad)))
		i += copy(data[i:], *m.Idforad)
	}
	if m.AndroididMd5 != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.AndroididMd5)))
		i += copy(data[i:], *m.AndroididMd5)
	}
	if m.AndroididSha1 != nil {
		data[i] = 0xb2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.AndroididSha1)))
		i += copy(data[i:], *m.AndroididSha1)
	}
	if m.MacaddressMd5 != nil {
		data[i] = 0xba
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.MacaddressMd5)))
		i += copy(data[i:], *m.MacaddressMd5)
	}
	if m.MacaddressSha1 != nil {
		data[i] = 0xc2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.MacaddressSha1)))
		i += copy(data[i:], *m.MacaddressSha1)
	}
	if m.IdforadEnabled != nil {
		data[i] = 0xc8
		i++
		data[i] = 0x1
		i++
		if *m.IdforadEnabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Category != nil {
		data[i] = 0xd2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Category)))
		i += copy(data[i:], *m.Category)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *User) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *User) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Yob != nil {
		data[i] = 0x8
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Yob))
	}
	if m.Ethnicity != nil {
		data[i] = 0x10
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Ethnicity))
	}
	if m.Gender != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Gender)))
		i += copy(data[i:], *m.Gender)
	}
	if m.Income != nil {
		data[i] = 0x20
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Income))
	}
	if m.Marital != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Marital)))
		i += copy(data[i:], *m.Marital)
	}
	if len(m.Ext) > 0 {
		for _, msg := range m.Ext {
			data[i] = 0x32
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ThirdPartyKeyValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ThirdPartyKeyValue) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Key)))
		i += copy(data[i:], *m.Key)
	}
	if m.Value != nil {
		data[i] = 0x12
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Value)))
		i += copy(data[i:], *m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BidRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiVersion != nil {
		data[i] = 0x8
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.ApiVersion))
	}
	if m.AuctionId != nil {
		data[i] = 0x12
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.AuctionId)))
		i += copy(data[i:], *m.AuctionId)
	}
	if len(m.MatchingAdIds) > 0 {
		for _, msg := range m.MatchingAdIds {
			data[i] = 0x1a
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PubWebsiteId != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.PubWebsiteId)))
		i += copy(data[i:], *m.PubWebsiteId)
	}
	if m.AdHeight != nil {
		data[i] = 0x28
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.AdHeight))
	}
	if m.AdWidth != nil {
		data[i] = 0x30
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.AdWidth))
	}
	if m.UserCookieId != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.UserCookieId)))
		i += copy(data[i:], *m.UserCookieId)
	}
	if m.UserIpAddress != nil {
		data[i] = 0x42
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(m.UserIpAddress)))
		i += copy(data[i:], m.UserIpAddress)
	}
	if m.UserScreenHeight != nil {
		data[i] = 0x48
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.UserScreenHeight))
	}
	if m.UserScreenWidth != nil {
		data[i] = 0x50
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.UserScreenWidth))
	}
	if m.UserGeoCountry != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.UserGeoCountry)))
		i += copy(data[i:], *m.UserGeoCountry)
	}
	if m.UserGeoState != nil {
		data[i] = 0x62
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.UserGeoState)))
		i += copy(data[i:], *m.UserGeoState)
	}
	if m.UserGeoDma != nil {
		data[i] = 0x68
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.UserGeoDma))
	}
	if m.UserAgent != nil {
		data[i] = 0x72
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.UserAgent)))
		i += copy(data[i:], *m.UserAgent)
	}
	if len(m.UserLang) > 0 {
		for _, s := range m.UserLang {
			data[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Url != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Url)))
		i += copy(data[i:], *m.Url)
	}
	if m.HttpReferer != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.HttpReferer)))
		i += copy(data[i:], *m.HttpReferer)
	}
	if m.OxCatTier_1 != nil {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.OxCatTier_1))
	}
	if m.OxCatTier_2 != nil {
		data[i] = 0x98
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.OxCatTier_2))
	}
	if len(m.PubBlockedCat) > 0 {
		for _, num := range m.PubBlockedCat {
			data[i] = 0xa0
			i++
			data[i] = 0x1
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(num))
		}
	}
	if len(m.PubBlockedContent) > 0 {
		for _, num := range m.PubBlockedContent {
			data[i] = 0xa8
			i++
			data[i] = 0x1
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(num))
		}
	}
	if len(m.PubBlockedType) > 0 {
		for _, num := range m.PubBlockedType {
			data[i] = 0xb0
			i++
			data[i] = 0x1
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(num))
		}
	}
	if len(m.PubBlockedUrl) > 0 {
		for _, s := range m.PubBlockedUrl {
			data[i] = 0xba
			i++
			data[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.RtbData != nil {
		data[i] = 0xc2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.RtbData)))
		i += copy(data[i:], *m.RtbData)
	}
	if len(m.PubBlockedAdLanguages) > 0 {
		for _, s := range m.PubBlockedAdLanguages {
			data[i] = 0xca
			i++
			data[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.MarketOperator != nil {
		data[i] = 0xd2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.MarketOperator)))
		i += copy(data[i:], *m.MarketOperator)
	}
	if m.Device != nil {
		data[i] = 0xda
		i++
		data[i] = 0x1
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.Device.Size()))
		n5, err := m.Device.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.IsTest != nil {
		data[i] = 0xe0
		i++
		data[i] = 0x1
		i++
		if *m.IsTest {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.IsMobileSite != nil {
		data[i] = 0xe8
		i++
		data[i] = 0x1
		i++
		if *m.IsMobileSite {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.IsApplication != nil {
		data[i] = 0xf0
		i++
		data[i] = 0x1
		i++
		if *m.IsApplication {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.TpKeyVal) > 0 {
		for _, msg := range m.TpKeyVal {
			data[i] = 0xfa
			i++
			data[i] = 0x1
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ImplementationType != nil {
		data[i] = 0x82
		i++
		data[i] = 0x2
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.ImplementationType)))
		i += copy(data[i:], *m.ImplementationType)
	}
	if m.SslEnabled != nil {
		data[i] = 0x88
		i++
		data[i] = 0x2
		i++
		if *m.SslEnabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.User != nil {
		data[i] = 0x92
		i++
		data[i] = 0x2
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.User.Size()))
		n6, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.PubAdUnitId != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x2
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.PubAdUnitId)))
		i += copy(data[i:], *m.PubAdUnitId)
	}
	if m.Video != nil {
		data[i] = 0xa2
		i++
		data[i] = 0x2
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.Video.Size()))
		n7, err := m.Video.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.App != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x2
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.App.Size()))
		n8, err := m.App.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Site != nil {
		data[i] = 0xb2
		i++
		data[i] = 0x2
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.Site.Size()))
		n9, err := m.Site.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BidResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BidResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiVersion == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x8
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.ApiVersion))
	}
	if m.AuctionId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.AuctionId)))
		i += copy(data[i:], *m.AuctionId)
	}
	if m.DEPRECATEDMatchingAdId != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.DEPRECATEDMatchingAdId.Size()))
		n10, err := m.DEPRECATEDMatchingAdId.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.DEPRECATEDCpmBidMicros != nil {
		data[i] = 0x20
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.DEPRECATEDCpmBidMicros))
	}
	if m.DEPRECATEDAdCode != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.DEPRECATEDAdCode)))
		i += copy(data[i:], *m.DEPRECATEDAdCode)
	}
	if m.DEPRECATEDClickUrl != nil {
		data[i] = 0x32
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.DEPRECATEDClickUrl)))
		i += copy(data[i:], *m.DEPRECATEDClickUrl)
	}
	if m.DEPRECATEDAdvertiserId != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.DEPRECATEDAdvertiserId)))
		i += copy(data[i:], *m.DEPRECATEDAdvertiserId)
	}
	if len(m.DEPRECATEDAdOxCats) > 0 {
		for _, num := range m.DEPRECATEDAdOxCats {
			data[i] = 0x40
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(num))
		}
	}
	if len(m.DEPRECATEDClickThroughUrls) > 0 {
		for _, s := range m.DEPRECATEDClickThroughUrls {
			data[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.DEPRECATEDBuyerId != nil {
		data[i] = 0x52
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.DEPRECATEDBuyerId)))
		i += copy(data[i:], *m.DEPRECATEDBuyerId)
	}
	if m.DEPRECATEDBrandId != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.DEPRECATEDBrandId)))
		i += copy(data[i:], *m.DEPRECATEDBrandId)
	}
	if len(m.Bids) > 0 {
		for _, msg := range m.Bids {
			data[i] = 0x62
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NextHighestBidMicros != nil {
		data[i] = 0x68
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.NextHighestBidMicros))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Bid) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Bid) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MatchingAdId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.MatchingAdId.Size()))
		n11, err := m.MatchingAdId.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.CpmBidMicros == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x10
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.CpmBidMicros))
	}
	if m.AdCode == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x1a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.AdCode)))
		i += copy(data[i:], *m.AdCode)
	}
	if len(m.AdOxCats) > 0 {
		for _, num := range m.AdOxCats {
			data[i] = 0x20
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(num))
		}
	}
	if len(m.ClickThroughUrls) > 0 {
		for _, s := range m.ClickThroughUrls {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.BuyerId != nil {
		data[i] = 0x32
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.BuyerId)))
		i += copy(data[i:], *m.BuyerId)
	}
	if m.BrandId != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.BrandId)))
		i += copy(data[i:], *m.BrandId)
	}
	if m.Crid != nil {
		data[i] = 0x42
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Crid)))
		i += copy(data[i:], *m.Crid)
	}
	if m.CanPassback != nil {
		data[i] = 0x48
		i++
		if *m.CanPassback {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.AgencyId != nil {
		data[i] = 0x52
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.AgencyId)))
		i += copy(data[i:], *m.AgencyId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuctionResults) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuctionResults) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiVersion == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x8
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.ApiVersion))
	}
	if m.AuctionId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x12
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.AuctionId)))
		i += copy(data[i:], *m.AuctionId)
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			data[i] = 0x1a
			i++
			i = encodeVarintOpenxRtb(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuctionResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuctionResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MatchingAdId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0xa
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(m.MatchingAdId.Size()))
		n12, err := m.MatchingAdId.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Status == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		data[i] = 0x10
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.Status))
	}
	if m.LossReason != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.LossReason)))
		i += copy(data[i:], *m.LossReason)
	}
	if m.ErrorReason != nil {
		data[i] = 0x22
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.ErrorReason)))
		i += copy(data[i:], *m.ErrorReason)
	}
	if m.WinningBidMicros != nil {
		data[i] = 0x28
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.WinningBidMicros))
	}
	if m.ClearingPriceMicros != nil {
		data[i] = 0x30
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(*m.ClearingPriceMicros))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Publisher) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Publisher) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOpenxRtb(data, i, uint64(len(*m.Id)))
		i += copy(data[i:], *m.Id)
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64OpenxRtb(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32OpenxRtb(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintOpenxRtb(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
